cameras:
    perspective:
        type: flat
sources:
    osm:
        type: TopoJSONTiles
        url:  //vector.mapzen.com/osm/all/{z}/{x}/{y}.topojson?api_key=vector-tiles-P6dkVl4
styles:
    space-tile:
        shaders:
            defines:
                TILE_SCALE: 0.0002445
                NORMALIZED_SHORT(x): (x * 32767.)
            blocks:
                global: |
                    // Variant to be add to both vertex and fragments shaders
                    varying vec3 v_pos;
                    //
                    // Get the coordinates in tile space
                    // ================================
                    vec2 getTileCoords () {
                        return fract(v_pos.xy*TILE_SCALE);
                    }

                position: |
                    // Normalize the attribute position of a vertex
                    v_pos = NORMALIZED_SHORT(a_position.xyz);
    tools-aastep:
        shaders:
            extensions: OES_standard_derivatives
            blocks:
                global: |
                    // AntiAliased Step function
                    //=============================
                    #ifdef TANGRAM_FRAGMENT_SHADER
                    float aastep(float threshold, float value) {
                      #ifdef TANGRAM_EXTENSION_OES_standard_derivatives
                        float afwidth = length(vec2(dFdx(value), dFdy(value))) * 0.70710678118654757;
                        return smoothstep(threshold-afwidth, threshold+afwidth, value);
                      #else
                        return step(threshold, value);
                      #endif  
                    }
                    #endif
    dots:
        base: polygons
        mix: [space-tile, tools-aastep]
        shaders:
            blocks: 
                global: |
                    #ifdef TANGRAM_FRAGMENT_SHADER
                    vec2 brickTile(vec2 st, float zoom){
                        st *= zoom;
                        if (fract(st.y * 0.5) > 0.5){
                            st.x += 0.5;
                          }
                          return fract(st);
                    }
                    float circleDF(vec2 st){
                        return dot(st,st);
                    }
                    float TileDots(float scale, float size) {
                        vec2 IN = brickTile(getTileCoords()*scale,2.);
                        float A = circleDF(vec2(0.5)-IN)*2.;

                        float d = 0.0;
                        if (u_map_position.z < 18.) {
                            vec2 OUT = fract(getTileCoords()*scale*2.);
                            
                            float B = circleDF(vec2(0.25)-OUT)*7.;
                            B = min(B, circleDF(vec2(0.75,0.25)-OUT)*7.);
                            B = min(B, circleDF(vec2(0.5,0.75)-OUT)*7.);
                            B = min(B, circleDF(vec2(0.,0.75)-OUT)*7.);
                            B = min(B, circleDF(vec2(1.,0.75)-OUT)*7.);
                        
                            d = mix(A, B, pow(fract(u_map_position.z),6.));
                        } else {
                            d = A;
                        }
                        return aastep(size,d);;
                    }
                    #endif
                color: |
                    color.rgb = mix(color.rgb,vec3(1.),TileDots(20.,.21));
layers:
    earth:
        data: { source: osm }
        draw:
            dots:
                order: 0
                color: '#555'
    water:
        data: { source: osm }
        draw:
            polygons:
                order: 1
                color: [1.000, 1.000, 1.000]